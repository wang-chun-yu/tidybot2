# TidyBot2 底盘控制系统详细技术文档

## 1. 系统概述

TidyBot2采用四轮独立转向驱动（4WIS/4WID）的移动底盘，每个脚轮包含一个转向电机和一个驱动电机，总共8个TalonFX电机。底盘控制系统实现了精确的全方向运动控制，支持平移、旋转及其组合运动。

### 1.1 核心特性

- **高精度控制**：250Hz实时控制循环
- **全方向移动**：支持任意方向的平移和旋转
- **平滑轨迹生成**：基于Ruckig的在线轨迹规划
- **安全保护**：多层次安全机制和电流限制
- **实时性能**：实时调度和低延迟通信

### 1.2 硬件架构

```
底盘控制系统
├── 4个脚轮模块
│   ├── 转向电机 (TalonFX, 奇数ID)
│   ├── 驱动电机 (TalonFX, 偶数ID) 
│   └── 转向编码器 (CANcoder)
├── CAN总线通信
└── Phoenix 6控制库
```

## 2. 物理参数与配置

### 2.1 底盘几何参数

| 参数 | 符号 | 数值 | 单位 | 说明 |
|------|------|------|------|------|
| 脚轮位置 | h_x | [0.190, 0.190, -0.190, -0.190] | m | 脚轮中心到底盘中心的x坐标 |
| 脚轮位置 | h_y | [-0.170, 0.170, 0.170, -0.170] | m | 脚轮中心到底盘中心的y坐标 |
| 脚轮偏移 | b_x | -0.014008 | m | 转向轴到接触点的前后偏移 |
| 脚轮偏移 | b_y | -0.003753 | m | 转向轴到接触点的左右偏移 |
| 轮子半径 | r | 0.0508 | m | 驱动轮半径 |

### 2.2 传动系统参数

| 参数 | 符号 | 计算公式 | 数值 | 说明 |
|------|------|----------|------|------|
| 转向齿轮比 | N_s | 32/15 × 60/10 | 12.8 | 转向电机到转向轴的减速比 |
| 驱动齿轮比1 | N_r1 | 50/14 | 3.571 | 驱动传动第一级减速比 |
| 驱动齿轮比2 | N_r2 | 19/25 | 0.76 | 驱动传动第二级减速比 |
| 轮子齿轮比 | N_w | 45/15 | 3.0 | 轮子传动减速比 |

### 2.3 控制参数

| 参数 | 数值 | 单位 | 说明 |
|------|------|------|------|
| 控制频率 | 250 | Hz | 主控制循环频率 |
| 最大线速度 | 0.5 | m/s | x、y方向最大速度 |
| 最大角速度 | 1.57 | rad/s | 绕z轴最大旋转速度 |
| 最大线加速度 | 0.25 | m/s² | x、y方向最大加速度 |
| 最大角加速度 | 0.79 | rad/s² | 绕z轴最大角加速度 |

## 3. 运动学模型

### 3.1 坐标系定义

- **全局坐标系**：固定在地面的参考坐标系
- **本体坐标系**：固定在底盘中心的坐标系
- **脚轮坐标系**：每个脚轮的局部坐标系

### 3.2 运动学约束

每个脚轮必须满足无滑移约束：
- 转向轮只能沿其朝向方向滚动
- 驱动轮垂直于转向轮方向滚动

### 3.3 运动学矩阵

#### C矩阵（运动学雅可比矩阵）
将本体坐标系下的底盘速度映射到关节速度：

```
dq = C × dx_local
```

其中：
- `dq`：关节速度向量 [θ̇₁, φ̇₁, θ̇₂, φ̇₂, θ̇₃, φ̇₃, θ̇₄, φ̇₄]ᵀ
- `dx_local`：本体坐标系下底盘速度 [vₓ, vᵧ, ωᵤ]ᵀ

转向关节的运动学关系：
```
C_steer[i, 0] = sin(θᵢ) / b_x
C_steer[i, 1] = -cos(θᵢ) / b_x  
C_steer[i, 2] = (-h_x[i]*cos(θᵢ) - h_y[i]*sin(θᵢ)) / b_x - 1.0
```

驱动关节的运动学关系：
```
C_drive[i, 0] = cos(θᵢ)/r - b_y*sin(θᵢ)/(b_x*r)
C_drive[i, 1] = sin(θᵢ)/r + b_y*cos(θᵢ)/(b_x*r)
C_drive[i, 2] = (h_x[i]*sin(θᵢ) - h_y[i]*cos(θᵢ))/r + b_y*(h_x[i]*cos(θᵢ) + h_y[i]*sin(θᵢ))/(b_x*r)
```

#### C_p矩阵（接触点运动学矩阵）
描述接触点处轮子速度与底盘速度的关系：

```
v_contact = C_p × dx_local
```

#### C_pinv矩阵（广义逆矩阵）
用于里程计计算，从关节速度推算底盘速度：

```
dx_local = C_pinv × dq
```

通过求解以下方程组得到：
```
C_pinv = (C_pᵀ × C_p)⁻¹ × C_pᵀ_Cqinv
```

### 3.4 里程计算法

1. **读取关节速度**：从电机编码器获取各关节的角速度
2. **计算本体速度**：使用广义逆矩阵计算本体坐标系下的速度
3. **坐标变换**：使用中点积分法转换到全局坐标系
4. **位姿更新**：积分速度得到新的位姿

```python
# 本体坐标系下速度
dx_local = C_pinv @ dq

# 中点积分法的平均角度
theta_avg = x[2] + 0.5 * dx_local[2] * dt

# 旋转矩阵
R = [[cos(theta_avg), -sin(theta_avg), 0],
     [sin(theta_avg),  cos(theta_avg), 0],
     [0,               0,              1]]

# 全局坐标系下速度和位姿更新
dx = R @ dx_local
x += dx * dt
```

## 4. 控制系统架构

### 4.1 分层控制结构

```
应用层命令
    ↓
轨迹规划器 (Ruckig OTG)
    ↓
运动学逆解
    ↓
关节速度控制
    ↓
电机控制 (TalonFX FOC)
    ↓
硬件执行
```

### 4.2 实时控制循环

控制循环以250Hz运行，每个周期包含以下步骤：

1. **状态更新**
   - 读取所有传感器数据
   - 更新运动学矩阵
   - 计算里程计

2. **命令处理**
   - 检查命令队列
   - 解析速度/位置命令
   - 坐标系转换

3. **轨迹生成**
   - 在线轨迹规划
   - 速度/加速度限制
   - 平滑性保证

4. **运动控制**
   - 运动学逆解
   - 关节速度计算
   - 电机命令发送

5. **安全监控**
   - 命令超时检测
   - 脚轮翻转保护
   - 电流限制监控

### 4.3 在线轨迹生成（OTG）

使用Ruckig库实现实时轨迹规划：

**特性**：
- 时间最优轨迹
- 考虑速度和加速度约束
- 支持位置和速度控制模式
- 实时性能保证

**控制模式**：
- **速度控制**：给定目标速度，生成平滑的速度轨迹
- **位置控制**：给定目标位置，生成位置和速度轨迹

## 5. 电机控制详解

### 5.1 TalonFX电机配置

每个TalonFX电机配置包括：

```python
# 速度控制增益
k_p = 5.0                    # 比例增益
k_d = 0.1 (转向) / 0.0 (驱动) # 微分增益

# 电流限制
转向电机：40A
驱动电机：10A

# 控制模式
VelocityTorqueCurrentFOC     # 基于FOC的速度控制
```

### 5.2 脚轮级控制

每个脚轮包含转向和驱动的耦合控制：

**转向电机速度**：
```
ω_steer_motor = N_s × ω_steer_joint
```

**驱动电机速度**（考虑转向耦合）：
```
ω_drive_motor = N_r1 × ω_steer_joint - N_r1_r2_w × ω_drive_joint
```

### 5.3 电机状态反馈

- **位置反馈**：电机编码器 + CANcoder绝对编码器
- **速度反馈**：电机编码器微分
- **电流反馈**：实时电流监控
- **电压反馈**：供电电压监控

## 6. 安全机制

### 6.1 多层安全保护

1. **硬件层**
   - 电流限制（40A转向，10A驱动）
   - 电压监控（最低11.5V）
   - Phoenix Pro许可证验证

2. **软件层**
   - 单实例运行（PID文件锁）
   - 命令超时保护（2.5倍策略周期）
   - 脚轮翻转减速保护
   - 速度/加速度限制

3. **系统层**
   - 实时调度优先级
   - CAN总线状态监控
   - 控制循环时序监控

### 6.2 故障处理

**电压过低**：
```python
if supply_voltage < 11.5:
    raise Exception('电机供电电压过低，请给电池充电')
```

**命令超时**：
```python
if time.time() - last_command_time > 2.5 * POLICY_CONTROL_PERIOD:
    # 保持当前位置，禁用电机
    disable_motors = True
```

**脚轮翻转保护**：
```python
if max(abs(steer_velocities)) > 12.56:  # > 720°/s
    # 减速或停止
    target_velocity = zeros()
```

## 7. 编程接口

### 7.1 主要类和方法

#### Vehicle类
```python
class Vehicle:
    def __init__(self, max_vel, max_accel)
    def start_control()                    # 启动控制循环
    def stop_control()                     # 停止控制循环
    def set_target_velocity(velocity, frame)  # 设置目标速度
    def set_target_position(position)      # 设置目标位置
    def get_encoder_offsets()              # 获取编码器偏移（标定用）
```

#### Caster类
```python
class Caster:
    def get_positions()                    # 获取转向和驱动位置
    def get_velocities()                   # 获取转向和驱动速度
    def set_velocities(steer_vel, drive_vel)  # 设置目标速度
    def set_neutral()                      # 设置空档
```

#### Motor类
```python
class Motor:
    def get_position()                     # 获取电机位置
    def get_velocity()                     # 获取电机速度  
    def set_velocity(velocity)             # 设置目标速度
    def set_neutral()                      # 设置空档
```

### 7.2 使用示例

#### 基本使用
```python
# 创建底盘控制器
vehicle = Vehicle(max_vel=(0.5, 0.5, 1.57))

# 启动控制循环
vehicle.start_control()

# 设置速度命令（全局坐标系）
vehicle.set_target_velocity([0.2, 0.0, 0.0])  # 前进0.2m/s

# 设置速度命令（本体坐标系）  
vehicle.set_target_velocity([0.2, 0.0, 0.0], frame='local')

# 设置位置命令
vehicle.set_target_position([1.0, 0.5, 0.785])  # 移动到(1,0.5)位置，转向45°

# 停止控制
vehicle.stop_control()
```

#### 实时控制示例
```python
import time
import numpy as np

vehicle = Vehicle()
vehicle.start_control()

try:
    # 圆形轨迹
    for i in range(100):
        t = i * 0.1
        vx = 0.2 * np.cos(t)
        vy = 0.2 * np.sin(t) 
        wz = 0.1
        vehicle.set_target_velocity([vx, vy, wz])
        time.sleep(0.1)
finally:
    vehicle.stop_control()
```

## 8. 标定与维护

### 8.1 编码器标定

转向编码器需要标定零位偏移：

```python
# 手动将所有脚轮调整到正前方
vehicle.get_encoder_offsets()
# 输出：ENCODER_MAGNET_OFFSETS = [offset1, offset2, offset3, offset4]
# 将输出值更新到constants.py中
```

### 8.2 参数调整

**速度控制增益调整**：
- 增加`k_p`：提高响应速度，但可能引起振荡
- 增加`k_d`：提高阻尼，减少振荡（仅转向电机）

**电流限制调整**：
- 根据地面条件和负载调整电流限制
- 硬地面：转向40A，驱动10A
- 软地面或有坡度：可适当增加

**速度限制调整**：
- 根据应用需求调整最大速度和加速度
- 测试时建议使用较低的速度限制

### 8.3 故障诊断

**常见问题**：

1. **控制循环时序警告**
   - 原因：系统负载过高或实时性不足
   - 解决：检查CPU使用率，配置实时调度

2. **电机不响应**
   - 原因：CAN总线通信问题或电机配置错误
   - 解决：检查CAN连接，验证电机ID

3. **脚轮抖动**
   - 原因：转向控制增益不当
   - 解决：调整转向电机的k_d增益

4. **运动不平滑**
   - 原因：轨迹规划参数或运动学参数错误
   - 解决：检查max_vel和max_accel设置

## 9. 性能优化

### 9.1 实时性优化

- 使用SCHED_FIFO实时调度
- 限制BLAS库线程数避免CPU争抢
- 优化CAN总线更新频率

### 9.2 精度优化

- 使用中点积分法提高里程计精度
- CANcoder绝对编码器提供高精度转向反馈
- 定期进行编码器标定

### 9.3 鲁棒性优化

- 多层安全保护机制
- 命令超时和脚轮翻转保护
- 电流和电压监控

## 10. 扩展与定制

### 10.1 自定义控制算法

可以通过修改`control_loop()`方法实现自定义控制算法：

```python
def custom_control_loop(self):
    while self.control_loop_running:
        # 自定义状态更新
        self.update_state()
        
        # 自定义控制逻辑
        # ...
        
        # 自定义电机命令
        for i, caster in enumerate(self.casters):
            caster.set_velocities(custom_steer_vel[i], custom_drive_vel[i])
```

### 10.2 传感器融合

可以集成额外的传感器改善定位精度：

- IMU：提供角速度和加速度测量
- 激光雷达：提供环境感知和定位
- 视觉里程计：提供视觉定位信息

### 10.3 高级功能

- **路径跟踪**：实现沿预定路径的精确跟踪
- **障碍物避障**：集成动态避障算法
- **多机器人协调**：支持多机器人编队控制

---

*本文档详细描述了TidyBot2底盘控制系统的设计原理、实现细节和使用方法。如有疑问，请参考源代码注释或联系开发团队。* 